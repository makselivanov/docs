# Трансформация данных

Трансформация — это преобразование данных с помощью особой функции-трансформера. Такие функции выполняются на потоке данных, применяются к каждому элементу изменений данных (data change item) и преобразуют их. Трансформер может работать и на уровне мета-информации, и на уровне самих данных.

Трансформацию данных можно настроить во время [создания](../operations/transfer.md#create) или [изменения](../operations/transfer.md#update) трансфера.

Трансформация данных доступна, только если источник и приемник имеют разные [типы](../concepts/index.md#connectivity-matrix).

Трансформеры задаются списком. При активации трансфера для подходящих под заданные условия таблиц составляется план трансформации. Трансформеры будут применяться к таблицам в том порядке, в котором они перечислены в списке.

## Типы трансформеров {#transformers-types}

Некоторые трансформеры могут иметь ограничения и применимы не для всех типов пар источник-приемник. Список трансформеров будет пополняться. В настоящий момент доступны следующие типы:

{% include [list-of-transformers](../../_includes/data-transfer/list-of-transformers.md) %}

### Переименование таблиц {#rename-tables}

Вы можете задать правила переименования таблиц, указав существующие имена таблиц в источнике и новые имена для этих таблиц в приемнике.

### Фильтр колонок {#columns-filter}

Вы можете настроить список столбцов таблиц для переноса:

1. С помощью списков включенных и исключенных таблиц задайте перечень таблиц, к которым будет применен фильтр.
1. С помощью списков включенных и исключенных колонок задайте перечень столбцов, которые должны перенестись в таблицы приемника.

### Маскирование данных {#data-mask}

Вы можете захэшировать данные:

1. С помощью списков включенных и исключенных таблиц задайте перечень таблиц, в которых будут маскироваться данные.
1. Укажите имя колонки для маскирования (регулярное выражение). Для каждой колонки укажите соль (строка типа пароль). Эта строка будет использована в функции `HMAC(sha256, salt)`, применяемой к данным в колонке.

### Разделение на подтаблицы {#subtable-splitting}

Трансфер разбивает таблицу `X` на несколько других `X_1`, `X_2`, …, `X_n` по данным. Если до разбиения строка находилась в таблице `X`, теперь она находится в таблице `X_i`, где `i` определяется следующими параметрами: список колонок и строка разбиения. 

> Пример:
> Если в списке колонок указаны две колонки `месяц рождения` и `пол`, а в строке разбиения указано `@`, то информация о сотруднике Иване, родившемся 11 февраля 1984 года, из таблицы `Сотрудники` попадет в таблицу `Сотрудники@февраль@мужской` — это новое имя таблицы.

Для разбиения таблиц:

1. С помощью списков включенных и исключенных таблиц задайте перечень таблиц.
1. Укажите колонки в таблицах для разбиения.
1. Укажите строку разбиения, которая будет соединять составляющие в новом имени таблицы.

### Замена первичных ключей {#replace-primary-key}

Для переопределения первичных ключей задайте список включенных и исключенных таблиц и список колонок, используемых в качестве первичного ключа.

### Преобразование значений колонок в строки {#convert-to-string}

Для преобразования значений колонок в строковые значения задайте список включенных и исключенных таблиц и список колонок. Значения будут преобразованы в зависимости от исходного типа:

| Исходный тип | Формат                                            |
|--------------|---------------------------------------------------|
| Any          | Сериализованный формат JSON                       |
| Date         | Строка вида `2006-01-02`                          |
| DateTime     | Строка вида `2006-01-02T15:04:05.999999999Z07:00` |

### Шардирование {#shard}

Задайте количество шардов для конкретных таблиц и список колонок, по значениям которых будет вычисляться хеш для определения шарда.

### Фильтр строк для APPEND-ONLY источников {#append-only-sources}

Этот фильтр применим только к трансферам, в которых в качестве источника данных используются очереди (например, {{ KF }}). При выполнении трансфера в потоке изменений остаются только те строки, которые удовлетворяют заданным критериям.

1. С помощью списков включенных и исключенных таблиц задайте перечень таблиц, в которых будут фильтроваться данные.
1. Задайте критерий для фильтрации. В качестве критерия можно задавать операции сравнения числовых, строковых и булевых значений и сравнение с NULL, а также проверку, входит ли подстрока в строку и принадлежит ли значение множеству.

Критерий фильтрации задается набором правил, разделенных ключевым словом `AND`. Допустимы операции `>`, `>=`, `<`, `<=`, `=`, `!=`, `~` (подстрока входит в строку), `!~` (подстрока не входит в строку), `IN` (значение принадлежит множеству), `NOT IN` (значение не принадлежит множеству). Все колонки, указанные в фильтре, должны быть представлены в фильтруемой таблице.

Пример строки-фильтра:
```text
aid > 0 AND id >= 10 AND f > 1000.1 AND f <= 1000.5 AND d != 3.14 AND i < 0 AND bi >= -9223372036854775808 AND biu <= 9223372036854775807 AND da > 1999-01-04 AND da <= 2000-03-04 AND ts > 2000-01-01T00:00:00 AND c != 'a' AND str ~ 'hello' AND t !~ 'bye-bye' AND nil = NULL AND val != NULL
```

Для фильтра поддерживается единственный уровень вложенности (скобки) и только с операторами `IN` и `NOT IN`.

Пример строки-фильтра с использованием операторов `IN` и `NOT IN`:
```sql
i IN (3, 5, 7) AND str IN ('hello', 'hi') AND c NOT IN ('a', 'b', 'c')
```

Особенности работы фильтра:

* Если тип значения, указанного для колонки в фильтре, не совпадает с типом этой колонки в фильтруемой таблице, то трансформер не применяется (строки не фильтруются).

* Если в фильтре указана строковая колонка, то тип этой колонки в фильтруемой таблице должен быть `UTF8` для источников, где парсер явно указывает типы колонок (например, для {{ DS }}). Колонки типа `STRING` трансформером не поддерживаются (строки не фильтруются).

Вы можете указывать сразу несколько критериев-фильтров. При указании нескольких критериев данные будут транспортироваться, если они удовлетворяют хотя бы одному из фильтров (аналог операции `OR`).

